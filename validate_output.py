"""
Validation script for MOSAIC_CONVERT output
"""
import pandas as pd
import os


def validate_mosaic_output(excel_file):
    """
    Validate Excel file generated by MOSAIC_CONVERT
    
    Parameters:
    -----------
    excel_file : str
        Path to the generated Excel file
    """
    
    if not os.path.exists(excel_file):
        print(f"ERROR: File not found {excel_file}")
        return False
    
    print("=" * 80)
    print(f"Validating file: {os.path.basename(excel_file)}")
    print("=" * 80)
    
    try:
        # Read worksheet
        xl = pd.ExcelFile(excel_file)
        print(f"\nOK: File opened successfully")
        print(f"  Worksheet list: {xl.sheet_names}")
        
        # Validate Index worksheet
        if 'Index' not in xl.sheet_names:
            print(f"\nERROR: 'Index' worksheet not found")
            return False
        
        df_index = pd.read_excel(excel_file, sheet_name='Index')
        
        print(f"\nOK: Index worksheet:")
        print(f"  - Rows: {len(df_index)}")
        print(f"  - Columns: {len(df_index.columns)}")
        
        # Validate required columns
        required_cols = ['sect_num', 'sect_ttl', 'PROGRAM', 'SUFFIX', 'outtype', 
                         'azsolid', 'Core', 'tocnumber', 'Output Type (Table, Listing, Figure)', 
                         'Title', 'OUTFILE']
        
        missing_cols = [col for col in required_cols if col not in df_index.columns]
        
        if missing_cols:
            print(f"\nERROR: Missing required columns: {missing_cols}")
            return False
        else:
            print(f"  OK: All required columns present")
        
        # Data quality check
        print(f"\nOK: Data quality check:")
        
        quality_checks = {
            'sect_num': lambda x: x.notna().sum(),
            'sect_ttl': lambda x: x.notna().sum(),
            'PROGRAM': lambda x: x.notna().sum(),
            'SUFFIX': lambda x: x.notna().sum(),
            'outtype': lambda x: x.notna().sum(),
            'azsolid': lambda x: x.notna().sum(),
            'tocnumber': lambda x: x.notna().sum(),
            'Output Type (Table, Listing, Figure)': lambda x: x.notna().sum(),
            'Title': lambda x: x.notna().sum(),
        }
        
        all_passed = True
        for col, check_func in quality_checks.items():
            count = check_func(df_index[col])
            total = len(df_index)
            pct = (count / total * 100) if total > 0 else 0
            status = "OK" if pct >= 95 else "WARN"
            print(f"  {status} {col:40s}: {count:3d}/{total:3d} ({pct:5.1f}%)")
            if pct < 95:
                all_passed = False
        
        # Output Type distribution
        print(f"\nOK: Output Type distribution:")
        output_type_counts = df_index['Output Type (Table, Listing, Figure)'].value_counts()
        for otype, count in output_type_counts.items():
            print(f"  - {otype:10s}: {count:3d}")
        
        # Check for empty Titles
        empty_titles = df_index[df_index['Title'].isna() | (df_index['Title'] == '')].shape[0]
        if empty_titles > 0:
            print(f"\nWARN: {empty_titles} rows have empty Title")
        
        # Display sample data
        print(f"\nOK: Data sample (first 3 rows):")
        sample_cols = ['sect_num', 'PROGRAM', 'SUFFIX', 'Output Type (Table, Listing, Figure)', 'Title']
        print(df_index[sample_cols].head(3).to_string(index=False))
        
        # Summary
        print("\n" + "=" * 80)
        if all_passed:
            print("OK: Validation passed! All checks meet expectations.")
        else:
            print("WARN: Validation complete, but some columns have data completeness below 95%.")
        print("=" * 80)
        
        return all_passed
        
    except Exception as e:
        print(f"\nERROR: Error during validation: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    import sys
    
    # Check command line arguments
    if len(sys.argv) > 1:
        # Use file path provided via command line
        target_file = sys.argv[1]
    else:
        # Try reading latest generated file path from .last_output.txt (UTF-8 encoding)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        last_output_file = os.path.join(script_dir, ".last_output.txt")
        
        if os.path.exists(last_output_file):
            try:
                with open(last_output_file, 'r', encoding='utf-8') as f:
                    target_file = f.read().strip()
                print(f"Reading path from .last_output.txt: {target_file}")
            except Exception as e:
                print(f"ERROR: Failed to read .last_output.txt: {e}")
                target_file = None
        else:
            # Default file path (backward compatible)
            target_file = os.path.join(script_dir, "02_output", "2026-02-09", "Clinical Study Report_TiFo_MOSAIC_CONVERT.xlsx")
    
    if target_file and os.path.exists(target_file):
        validate_mosaic_output(target_file)
    else:
        print(f"ERROR: File not found {target_file if target_file else '(not specified)'}")
        print(f"Usage: python validate_output.py [file path]")
